\chapter{Express (Michi)}\label{express-michi}

\textbf{Grobschrift, da muss noch viel geändert und zitiert werden.}

Express ist der de-facto Standard für Node.js Webframeworks. Es gibt
sehr viele Alternativen (koa\cite{koa}, hapi\cite{hapi}, total.js\cite{totaljs}), jedoch gibt es
kein anderes Framework, das so viele Benutzer und Mitwirker hat.

% hier Vergleich der verschiedenen Stars etc. machen und in den Anhang

Verglichen mit Webframeworks, die sich in anderen Sprachen etabliert
haben, ist Express leichtgewichtig und liefert wenig Funktionalität.
Frameworks aus Programmiersprachen wie z.B.

\begin{itemize}
\item
  Ruby on Rails in Ruby
\item
  Spring in Java
\item
  Symfony in PHP
\item
  Django in Python
\end{itemize}

liefern Funktionalität für typische Webanwendungen (Sessions, Cookies,
Authentifizierung, Form Handling, Templating, \ldots{}).

Strongloop\cite{strongloop}, die Firma hinter Express, bietet inzwischen Training für Node.js und API
Entwicklung an.

Erweiterte Funktionalität muss bei Express über 3rd-Party Erweiterungen
hinzugefügt werden. Die Wartung dieser Erweiterungen wird dabei nicht
kontrolliert oder von den Entwicklern von Express beeinflusst.

Die Probleme die sich hieraus enwickeln können, werden in den nächsten Kapiteln diskutiert.

\section{Installation und
Versionierung}\label{installation-und-versionierung}

Die Installation von Express erfolgt über npm (den Node Package Manager)
und macht wenig Probleme. Voraussetzung ist jedoch, dass die
installierte Version von Node, zu der gewünschten Express Version passt.

Im Umlauf befinden sich die Versionen 2, 3, 4 und 5, wobei 2 und 3 als
deprecated markiert wurden und sich 5 noch in aktiver Entwicklung
befindet. Problematisch hierbei ist wieder, dass sämtliche Erweiterungen
für Express zu den entsprechenden Versionen von Express passen müssen.

Entscheidet man sich für vordefinierte MEAN Stacks wie z.B. MEAN.IO oder
MEAN.JS, dann lassen sich einzelne Komponenten nur austauschen, falls
der Ersatz die entsprechenden Versionen von Express und Node
unterstützt. Auf Grund der häufig sehr hohen Anzahl an Erweiterungen ist
dies oft problematisch.

\section{Kernfunktionalität}\label{kernfunktionalituxe4t}

Die Kernfunktionalität von Express ist, wie bereits erwähnt wurde, sehr
beschränkt. Im Prinzip übernimmt Express lediglich das Routing der
Requests auf, vom Entwickler definierte, Callbacks.

Einige Funktionen wie z.B. das Parsing einer Anfrage oder senden von Cookies
sind eigentlich Kern einer jeder Webanwendung. Express benötigt jedoch sogar für
diese Funktionen Erweiterungen.

Erweiterte Funktionalität wird über Middlewares ermöglicht. Middlewares
können das Request und Response Objekt verändern und weiter- bzw.
umleiten oder terminieren (z.B. falls keine Zugriffsrechte bestehen).

\section{Anwendung}\label{anwendung}

Da Javascript ist eine Prototyp-basierte Sprache, die zumindest vor dem
ES6 Standard kein Klassenkonzept kennt. Deshalb und auf Grund der Art wie Express
die Routes (URI Endpunkte einer Anwendung) verarbeitet, ist es nicht möglich Controller als Klassen wie
in einer typischen MVC (Model View Controller) Architektur umzusetzen.

Aus Gründen der Übersichtlichkeit und um die Funktionalität zu kapseln
und damit ggf. wiederverwendbar zu machen, haben wir die Callbacks der Routes in
eine Controller-ähnliche Struktur gebracht. Die jeweiligen Funktionen
auf den Controllern entsprechen dabei statischen Funktionen anderer
Programmiersprachen\footnote{wie bereits erwähnt ist es in Express nicht möglich
Methoden auf instanziierten Controllern aufzurufen}.

\begin{verbatim}
/**
 * Creates a ProjectController
 * @returns {ProjectController}
 */
module.exports = function() {

  'use strict';

  /**
   * Updates an given project and returns the updated object.
   *
   * @param {http.IncomingMessage} req Express Request Object
   * @param {http.OutgoingMessage} res Express Response Object
   * @callback next Callback which calls the next matching route.
   */
  ProjectController.prototype.update = function(req, res, next) {
    // ...
  };

  return new ProjectController();
};
\end{verbatim}
\lstset{basicstyle=\footnotesize\ttfamily, language=JavaScript, showspaces=false }
\section{Dependency Injection}\label{dependency-injection}

Da die Funktionalität in Express üblicherweise\cite{express-routing}
via Callbacks realisiert wird, ist es nicht möglich Abhängigkeiten
separat zu verwalten. Die Callbacks von Express kennen lediglich die
Parameter \texttt{req}, \texttt{res} und \texttt{next}. Express
unterstützt Dependency Injection nicht als Kernfunktionalität.

Dies hat zur Folge, dass die Erstellung von Objekten vielfach dupliziert
wird und außerdem schlecht testbar ist. Die Abhängigkeiten werden
typischerweise im Callback instanziiert und können somit nicht durch
Mockobjekte ausgetauscht werden.

Es existieren 3rd-Party Erweiterungen wie z.B. express-di\cite{express-di} oder
express-dinja\cite{express-dinja}, diese
waren aber entweder nicht mit unserer Version von Express kompatibel
oder konnten nicht mit unserem Controller-Konzept vereinbart werden.

Eine eigene minimale Implementierung \footnote{die von den genannten
Erweiterungen ähnlich implementiert wird} wurde via Middlewares
realisiert. Ein Dependency Injection Container wird dabei an das Request
Objekt \texttt{req} angehängt. Diese Lösung ist nicht optimal und
verletzt u.a. das Single Responsibility Principle
\cite{srp}. Express verhindert jedoch eine
andere Implementierungsweise.

\begin{figure}[t]
	\centering
	\begin{lstlisting}
		var dicMiddleware = function(req, res, next) {
		  req.dic = {
		    subjectRepository: require('../models/SubjectRepository'),
		  };
		  next();
		};
		subjectRouter.use('/', dicMiddleware);
	\end{lstlisting}
	\caption[dicMiddleware]{TODO: Programmbeispiel für eine dicMiddleware}
	\label{f:dicMiddleware}
\end{figure}

Mit dieser Implementierung war es uns möglich die Controller zu testen,
da lediglich Mockobjekte für \texttt{req} und \texttt{res} erzeugt
werden müssen.

\section{Typische Probleme der
Webentwicklung}\label{typische-probleme-der-webentwicklung}

Express unterstützt die häufigst verwendeten Javascript Template Engines
(\href{http://github.com/visionmedia/jade}{Jade},
\href{http://github.com/visionmedia/ejs}{EJS},
\href{http://github.com/visionmedia/haml.js}{Haml}), liefert jedoch
keine eigene Implementierung.

Fair Projects nutzt Express als API und somit finden Templates in der
aktuellen Implementierung keinerlei Verwendung. Ein technischer
Durchstich hat sowohl mit Jade als auch EJS einwandfrei funktioniert.

Authentifizierung und Authorisierung kommen in den meisten klassischen
und modernen Single-Page Anwendungen vor. Express unterstützt weder
Sessions (es gibt aber eine offizielle Erweiterung
\href{https://github.com/expressjs/session}{express-session}), noch
Cookies und damit auch keine Authentifizierung. Die de-facto Erweiterung
zur Authentifizierung ist \href{http://passportjs.org/}{Passport}.

Fair Projects sollte ursprünglich ein externes
Authentifizierungsverfahren von Github, Twitter oder Facebook verwenden.
Die Erweiterungen hierzu von Passport (Passport ist ähnlich wie Express
modular aufgebaut und unterstützt selbst fast keine Verfahren) waren
entweder veraltet und durch neuere ersetzt oder haben sich so
weiterentwickelt, dass die Dokumentation nicht mit der Implementierung
übereinstimmte.

Wir entschieden uns daher für das sog. \texttt{LocalStrategy} Verfahren
also eine eigene Implementierung über z.B. eine Datenbank. Die
Dokumentation von Passport war auch hier nicht immer hilfreich, da viele
externe Plugins (z.B. für Cookies und Session) benötigt werden und die
Dokumentation diese nicht ausreichend beschreibt.

Die aktuelle Implementierung legt Benutzer in der MongoDB Datenbank ab,
verifiziert diese bei (API) Login und speichert die Session via Node.
Benutzer müssen über die API erstellt werden.

\begin{quote}
Hierbei handelt es sich um ein minimalistisches und flexibles
Webframework für Node.js. Es dient der einfacheren Entwicklung moderner
Webanwendungen.
\end{quote}

\begin{quote}
Vorteile - sehr viele Plugins - modularer Aufbau
\end{quote}

\begin{quote}
Nachteile - erlaubt keine schoene Kapselung (Controller Problem also
z.B. hat eine Methode keinen Zugriff auf this) - DI (Dependency
Injection) nur ueber Umweg ueber Middleware moeglich - quick and dirty
\end{quote}